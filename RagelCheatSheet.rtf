{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf340
\cocoascreenfonts1{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww13380\viewh14740\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\b\fs40 \cf0 Ragel Concept Cheat Sheet
\b0\fs24 \
Jeremy W. Sherman\
2010\'9611\'9623\
\
All information comes from the Ragel guide for Ragel version 6.6, which I guess makes this document 
\b GPLv2-licensed
\b0 .\
\

\b Ragel compiles state machines with actions.
\b0 \
Ragel builds Mealy machines: Actions label arcs, so they are emitted on state change. Ragel compiles machine descriptions into executable code. Actions are written in the host language. Actions can manipulate machine behavior in order to recognize non-regular languages.\
\
Ragel preprocesses a .rl file to generate an output parser. The file has embedded actions written in the target compilation language, and scaffolding to set up the scanning environment for consumption by Ragel.\
\
%% introduces a single-line directive. %%\{\'85\}%% wraps a Ragel block.\
\
You can include another Ragel file with a specific name as:\
	include FsmName "inputfile.rl"\
\
You can import definitions of literal strings or numbers in particular formats ("name = val" or "define name val") using:\
	import "inputfile";\
\
Note how these two formats match C enum tags and preprocessor #defines.\
\
# is treated as a line comment within a Ragel block. There is no multi-line comment character; just keep prefixing comment lines with #.\
\

\b Machines
\b0 \
The most basic machine is the regular expression. More complicated machines are built by combining regular expressions using operators. Unwanted non-determinism can be removed by prioritizing some transitions over others.\
\
Name an entire Ragel block by including:\
	machine fsm_name;\
\
Define submachines with:\
	name = expression;\
\
Define and instantiate with:\
	name := expression;\
\

\b Builtin Machines
\b0 \
Strings as a concatenation of characters quoted with either single or double quotes.\
\
Named builtin machines are mostly the XXX parts of the C isXXX functions, but there's also zlen (zero-length string), any, and empty (AKA ^any). extend is extended ASCII, whatever will fit in an 8-bit (signed or unsigned as per your alphabet) value.\
\

\b Operators\

\b0 The standard regex/set operations:\
	union |\
	intersection &\
	subtraction - -- (see Subtraction note below)\
\
	concatenation .\
	repetition * ? + \{n\} \{,n\} \{n,\} \{n,m\}\
	negation !\
	character negation ^\
\
	grouping with parentheses\
\
Subtraction: There are two varieties of subtraction, regular subtraction - and strong subtraction --. Subtraction prevents input that would match m2 and m1 from matching. Strong subtraction prevents input that would match m1 and contains any substring that would match m2 from matching. Strong subtraction m1 -- m2 is equivalent to m1 - ( any* m2 any* ).\
\
Concatenation is the default operator joining two machines when none other is specified. Watch out for (M -7), which is understood as (M - (7)). Either add an explicit . or group the (-7).\
\

\b Actions\

\b0 Actions look like:\
\
	action ActionName \{\
		code block\
	\}\
\
The name is optional; you can just embed a bare \{ code block \}. But naming makes your patterns more readable and makes it easy to reuse the same block.\
\

\b Transition action embeddings
\b0  (machine OP action):\
	> entering \'96 transition from initial state\
	$ all \'96 all transitions within the machine\
	@ finishing \'96 transition into final state\
	% leaving \'96 transition from final state\
Can embed actions at multiple transitions for a machine, such as (M >ENTER $ALL @FINISH %LEAVE).\
\

\b State action embeddings
\b0  are specified in two parts, state class and embedding type. They are used to specify error/EOF actions for different states. Note that these put actions in the state bubbles, rather than on the transition arcs.\
\
State classes (symbol and description):\
	< \'96 non-initial\
	> \'96 initial\
	$ \'96 all\
	@ \'96 non-final\
	% \'96 final\
	<> \'96 non-initial, non-final\
\
Event types (symbol and alternative keyword):\
	~ \'96 to\
	* \'96 from\
	/ \'96 eof\
	! \'96 err (global error)\
	^ \'96 leer (local error)\
\
Write a state-action embedding in one of three ways:\
	>~action \'96 all symbols; either >~ActionName or >~\{ code block \} would work fine\
	>to(name) \'96 using the keyword; the action name must now be bracketed by parens\
	>to\{\'85\} \'96 directly embedding a code block\
\
Note how using an alphabetic keyword requires special syntax for the action name case.\
\
EOF means end of the current input, i.e., p == pe. These can be used to twiddle p and jump to another state.\
\
Global error actions start as actions attached to the labeled state, but become transition actions to the error state after compilation is complete. The transition is triggered for all input characters not handled by the state's other transitions. It also becomes an EOF action if the state it was embedded in was non-final (i.e., EOF was also an invalid "next character").\
\
Local error actions are associated with machine names. After compilation of the machine definition (rather than overall compilation), all local errors with the same name as the machine definition get transferred to the error transitions (and EOF actions for non-final states). The name defaults to the current machine, but it can be specified using (name, action) as the action. They can be used to recover from within a submachine.\
\
A common way to try to recover is to fhold (AKA p--) then fgoto to a machine that eats input till a sync point, like a newline.\
\

\b Priorities
\b0  use literal numbers along with the transition action embedding symbols, like >1. Higher-priority transitions kill lower-priority when they have the same name. The name defaults to the current machine, but can be specified explicitly as >(name, 1). Prefer specifying the name to avoid unwanted interactions between priorities introduced to solve one problem and those introduced to specify another.\
\
Priorities are powerful but also require a nuanced understanding at the state machine level. There is also the possibility of name collisions in larger machines. So, some operators, called 
\b guarded operators
\b0 , handle common uses of priorities for you:\
	<: \'96 left-guarded concatenation: prioritize M1's transitions (prefix one sequence that overlaps another) M1 $(N,1) . M2 >(N,0)\
	:> \'96 entry-guarded concatenation:  prioritize M2's entering transitions (terminate M1 on entering M2) M1 $(N,0) . M2 >(N,1)\
	:>> \'96  finish-guarded concatenation: prioritize M2's finishing transitions (terminate M1 when M2 hits a final state) roughly M1 $(N,0) . M2 @(N,1) \'96 will also prioritize leaving M2's start state if start is also final\
	** \'96 longest-match kleene star: prioritize all M1's transitions over M1's leaving transitions (greedy match) (M1 $(N,1) %(N,0))*\
\

\b Scanners
\b0  are created by jumping into an instantiated longest-match machine. The longest-match syntax looks like this:\
	|* pattern => action; pattern => action;*|;\
The => action part is optional. Longer matches are preferred over shorter. If two patterns match the same length text, the earlier one is preferred.\
\
Scanners rely on the ts (token start char*), te (token end char*), and act (active pattern int) variables.\
\

\b State charts
\b0  provide a way to manually specify state machines. You use the join operator , to combine machines without any transitions. You label the machines so you can target them for transition. In the machine description, you transition from a submachine to a label using epsilon transitions. Stupid example:\
\
M =\
label: (\
	'a' -> b\
),\
b: 'b' -> final;\
\
"final" seems to be an implicit state in the state chart meaning "we're done!"\
\

\b Semantic conditions
\b0  make handling variable-length fields easy. They look like (M when test_action), where test_action is an action block that returns true or false. The condition is tested just before a transition is taken; true takes the transition, false prevents it. This works by transforming the transition label to include the "condition true" information; this effectively adds a new "compound symbol" to the alphabet recognized by the machine.}